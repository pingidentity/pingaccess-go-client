/*
Administrative API Documentation

The PingAccess Administrative API is a REST-based interface that provides a programmatic way to make configuration changes to PingAccess as an alternative to using the administrative console.<br/><br/>Expand the resources below to display implementation details on that resource such as the available endpoints, the parameter and response models for the operation, and the model structure of the resources themselves. Each resource operation comes with the ability to interact with the API.

API version: 7.3.0.2-SNAPSHOT
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package configurationapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AuthenticationChallengePoliciesApiService AuthenticationChallengePoliciesApi service
type AuthenticationChallengePoliciesApiService service

type ApiAddAuthenticationChallengePolicyRequest struct {
	ctx                           context.Context
	ApiService                    *AuthenticationChallengePoliciesApiService
	authenticationChallengePolicy *AuthenticationChallengePolicy
}

// Authentication Challenge Policy to add
func (r ApiAddAuthenticationChallengePolicyRequest) AuthenticationChallengePolicy(authenticationChallengePolicy AuthenticationChallengePolicy) ApiAddAuthenticationChallengePolicyRequest {
	r.authenticationChallengePolicy = &authenticationChallengePolicy
	return r
}

func (r ApiAddAuthenticationChallengePolicyRequest) Execute() (*AuthenticationChallengePolicy, *http.Response, error) {
	return r.ApiService.AddAuthenticationChallengePolicyExecute(r)
}

/*
AddAuthenticationChallengePolicy Method for AddAuthenticationChallengePolicy

Create an Authentication Challenge Policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddAuthenticationChallengePolicyRequest
*/
func (a *AuthenticationChallengePoliciesApiService) AddAuthenticationChallengePolicy(ctx context.Context) ApiAddAuthenticationChallengePolicyRequest {
	return ApiAddAuthenticationChallengePolicyRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticationChallengePolicy
func (a *AuthenticationChallengePoliciesApiService) AddAuthenticationChallengePolicyExecute(r ApiAddAuthenticationChallengePolicyRequest) (*AuthenticationChallengePolicy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticationChallengePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.AddAuthenticationChallengePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticationChallengePolicy == nil {
		return localVarReturnValue, nil, reportError("authenticationChallengePolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationChallengePolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAuthenticationChallengePolicyRequest struct {
	ctx        context.Context
	ApiService *AuthenticationChallengePoliciesApiService
	id         string
}

func (r ApiDeleteAuthenticationChallengePolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteAuthenticationChallengePolicyExecute(r)
}

/*
DeleteAuthenticationChallengePolicy Method for DeleteAuthenticationChallengePolicy

Delete an Authentication Challenge Policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of Authentication Challenge Policy to delete
	@return ApiDeleteAuthenticationChallengePolicyRequest
*/
func (a *AuthenticationChallengePoliciesApiService) DeleteAuthenticationChallengePolicy(ctx context.Context, id string) ApiDeleteAuthenticationChallengePolicyRequest {
	return ApiDeleteAuthenticationChallengePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
func (a *AuthenticationChallengePoliciesApiService) DeleteAuthenticationChallengePolicyExecute(r ApiDeleteAuthenticationChallengePolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.DeleteAuthenticationChallengePolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthenticationChallengePoliciesRequest struct {
	ctx           context.Context
	ApiService    *AuthenticationChallengePoliciesApiService
	page          *int64
	numberPerPage *int64
	filter        *string
	name          *string
	sortKey       *string
	order         *string
}

// Page number to retrieve
func (r ApiGetAuthenticationChallengePoliciesRequest) Page(page int64) ApiGetAuthenticationChallengePoliciesRequest {
	r.page = &page
	return r
}

// Number of Authentication Challenge Policies per page
func (r ApiGetAuthenticationChallengePoliciesRequest) NumberPerPage(numberPerPage int64) ApiGetAuthenticationChallengePoliciesRequest {
	r.numberPerPage = &numberPerPage
	return r
}

// Search for an Authentication Challenge Policy with name matching filter text
func (r ApiGetAuthenticationChallengePoliciesRequest) Filter(filter string) ApiGetAuthenticationChallengePoliciesRequest {
	r.filter = &filter
	return r
}

// Get a specific Authentication Challenge Policy by name (case-sensitive)
func (r ApiGetAuthenticationChallengePoliciesRequest) Name(name string) ApiGetAuthenticationChallengePoliciesRequest {
	r.name = &name
	return r
}

// A comma separated list of Authentication Challenge Policy attributes (keys) to be used to sort the results
func (r ApiGetAuthenticationChallengePoliciesRequest) SortKey(sortKey string) ApiGetAuthenticationChallengePoliciesRequest {
	r.sortKey = &sortKey
	return r
}

// Order of the sorted results (ASC for ascending, DESC for descending)
func (r ApiGetAuthenticationChallengePoliciesRequest) Order(order string) ApiGetAuthenticationChallengePoliciesRequest {
	r.order = &order
	return r
}

func (r ApiGetAuthenticationChallengePoliciesRequest) Execute() (*AuthenticationChallengePolicies, *http.Response, error) {
	return r.ApiService.GetAuthenticationChallengePoliciesExecute(r)
}

/*
GetAuthenticationChallengePolicies Method for GetAuthenticationChallengePolicies

Get all Authentication Challenge Policies

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAuthenticationChallengePoliciesRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetAuthenticationChallengePolicies(ctx context.Context) ApiGetAuthenticationChallengePoliciesRequest {
	return ApiGetAuthenticationChallengePoliciesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AuthenticationChallengePolicies
func (a *AuthenticationChallengePoliciesApiService) GetAuthenticationChallengePoliciesExecute(r ApiGetAuthenticationChallengePoliciesRequest) (*AuthenticationChallengePolicies, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticationChallengePolicies
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetAuthenticationChallengePolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.numberPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberPerPage", r.numberPerPage, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.sortKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortKey", r.sortKey, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAuthenticationChallengePolicyRequest struct {
	ctx        context.Context
	ApiService *AuthenticationChallengePoliciesApiService
	id         string
}

func (r ApiGetAuthenticationChallengePolicyRequest) Execute() (*AuthenticationChallengePolicy, *http.Response, error) {
	return r.ApiService.GetAuthenticationChallengePolicyExecute(r)
}

/*
GetAuthenticationChallengePolicy Method for GetAuthenticationChallengePolicy

Get an Authentication Challenge Policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of Authentication Challenge Policy to get
	@return ApiGetAuthenticationChallengePolicyRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetAuthenticationChallengePolicy(ctx context.Context, id string) ApiGetAuthenticationChallengePolicyRequest {
	return ApiGetAuthenticationChallengePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AuthenticationChallengePolicy
func (a *AuthenticationChallengePoliciesApiService) GetAuthenticationChallengePolicyExecute(r ApiGetAuthenticationChallengePolicyRequest) (*AuthenticationChallengePolicy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticationChallengePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetAuthenticationChallengePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChallengeResponseFilterDescriptorRequest struct {
	ctx                context.Context
	ApiService         *AuthenticationChallengePoliciesApiService
	responseFilterType string
}

func (r ApiGetChallengeResponseFilterDescriptorRequest) Execute() (*Descriptor, *http.Response, error) {
	return r.ApiService.GetChallengeResponseFilterDescriptorExecute(r)
}

/*
GetChallengeResponseFilterDescriptor Method for GetChallengeResponseFilterDescriptor

Get the descriptor for an Authentication Challenge Policy Response Filter type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param responseFilterType Response Filter descriptor to retrieve
	@return ApiGetChallengeResponseFilterDescriptorRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseFilterDescriptor(ctx context.Context, responseFilterType string) ApiGetChallengeResponseFilterDescriptorRequest {
	return ApiGetChallengeResponseFilterDescriptorRequest{
		ApiService:         a,
		ctx:                ctx,
		responseFilterType: responseFilterType,
	}
}

// Execute executes the request
//
//	@return Descriptor
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseFilterDescriptorExecute(r ApiGetChallengeResponseFilterDescriptorRequest) (*Descriptor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetChallengeResponseFilterDescriptor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/responseFilters/descriptors/{responseFilterType}"
	localVarPath = strings.Replace(localVarPath, "{"+"responseFilterType"+"}", url.PathEscape(parameterValueToString(r.responseFilterType, "responseFilterType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChallengeResponseFilterDescriptorsRequest struct {
	ctx        context.Context
	ApiService *AuthenticationChallengePoliciesApiService
}

func (r ApiGetChallengeResponseFilterDescriptorsRequest) Execute() (*Descriptors, *http.Response, error) {
	return r.ApiService.GetChallengeResponseFilterDescriptorsExecute(r)
}

/*
GetChallengeResponseFilterDescriptors Method for GetChallengeResponseFilterDescriptors

Get the descriptors for all the Authentication Challenge Policy Response Filtersr

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChallengeResponseFilterDescriptorsRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseFilterDescriptors(ctx context.Context) ApiGetChallengeResponseFilterDescriptorsRequest {
	return ApiGetChallengeResponseFilterDescriptorsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Descriptors
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseFilterDescriptorsExecute(r ApiGetChallengeResponseFilterDescriptorsRequest) (*Descriptors, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetChallengeResponseFilterDescriptors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/responseFilters/descriptors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChallengeResponseGeneratorDescriptorRequest struct {
	ctx                   context.Context
	ApiService            *AuthenticationChallengePoliciesApiService
	responseGeneratorType string
}

func (r ApiGetChallengeResponseGeneratorDescriptorRequest) Execute() (*Descriptor, *http.Response, error) {
	return r.ApiService.GetChallengeResponseGeneratorDescriptorExecute(r)
}

/*
GetChallengeResponseGeneratorDescriptor Method for GetChallengeResponseGeneratorDescriptor

Get the descriptor for an Authentication Challenge Policy Response Generator type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param responseGeneratorType Response Generator descriptor to retrieve
	@return ApiGetChallengeResponseGeneratorDescriptorRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseGeneratorDescriptor(ctx context.Context, responseGeneratorType string) ApiGetChallengeResponseGeneratorDescriptorRequest {
	return ApiGetChallengeResponseGeneratorDescriptorRequest{
		ApiService:            a,
		ctx:                   ctx,
		responseGeneratorType: responseGeneratorType,
	}
}

// Execute executes the request
//
//	@return Descriptor
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseGeneratorDescriptorExecute(r ApiGetChallengeResponseGeneratorDescriptorRequest) (*Descriptor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetChallengeResponseGeneratorDescriptor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/responseGenerators/descriptors/{responseGeneratorType}"
	localVarPath = strings.Replace(localVarPath, "{"+"responseGeneratorType"+"}", url.PathEscape(parameterValueToString(r.responseGeneratorType, "responseGeneratorType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChallengeResponseGeneratorDescriptorsRequest struct {
	ctx        context.Context
	ApiService *AuthenticationChallengePoliciesApiService
}

func (r ApiGetChallengeResponseGeneratorDescriptorsRequest) Execute() (*Descriptors, *http.Response, error) {
	return r.ApiService.GetChallengeResponseGeneratorDescriptorsExecute(r)
}

/*
GetChallengeResponseGeneratorDescriptors Method for GetChallengeResponseGeneratorDescriptors

Get the descriptors for all the Authentication Challenge Policy Response Generators

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChallengeResponseGeneratorDescriptorsRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseGeneratorDescriptors(ctx context.Context) ApiGetChallengeResponseGeneratorDescriptorsRequest {
	return ApiGetChallengeResponseGeneratorDescriptorsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Descriptors
func (a *AuthenticationChallengePoliciesApiService) GetChallengeResponseGeneratorDescriptorsExecute(r ApiGetChallengeResponseGeneratorDescriptorsRequest) (*Descriptors, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetChallengeResponseGeneratorDescriptors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/responseGenerators/descriptors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRequestMatcherDescriptorRequest struct {
	ctx                context.Context
	ApiService         *AuthenticationChallengePoliciesApiService
	requestMatcherType string
}

func (r ApiGetRequestMatcherDescriptorRequest) Execute() (*Descriptor, *http.Response, error) {
	return r.ApiService.GetRequestMatcherDescriptorExecute(r)
}

/*
GetRequestMatcherDescriptor Method for GetRequestMatcherDescriptor

Get the descriptor for an Authentication Challenge Policy Request Matcher type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param requestMatcherType Request Matcher descriptor to retrieve
	@return ApiGetRequestMatcherDescriptorRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetRequestMatcherDescriptor(ctx context.Context, requestMatcherType string) ApiGetRequestMatcherDescriptorRequest {
	return ApiGetRequestMatcherDescriptorRequest{
		ApiService:         a,
		ctx:                ctx,
		requestMatcherType: requestMatcherType,
	}
}

// Execute executes the request
//
//	@return Descriptor
func (a *AuthenticationChallengePoliciesApiService) GetRequestMatcherDescriptorExecute(r ApiGetRequestMatcherDescriptorRequest) (*Descriptor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetRequestMatcherDescriptor")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/requestMatchers/descriptors/{requestMatcherType}"
	localVarPath = strings.Replace(localVarPath, "{"+"requestMatcherType"+"}", url.PathEscape(parameterValueToString(r.requestMatcherType, "requestMatcherType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRequestMatcherDescriptorsRequest struct {
	ctx        context.Context
	ApiService *AuthenticationChallengePoliciesApiService
}

func (r ApiGetRequestMatcherDescriptorsRequest) Execute() (*Descriptors, *http.Response, error) {
	return r.ApiService.GetRequestMatcherDescriptorsExecute(r)
}

/*
GetRequestMatcherDescriptors Method for GetRequestMatcherDescriptors

Get the descriptors for all the Authentication Challenge Policy Request Matchers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRequestMatcherDescriptorsRequest
*/
func (a *AuthenticationChallengePoliciesApiService) GetRequestMatcherDescriptors(ctx context.Context) ApiGetRequestMatcherDescriptorsRequest {
	return ApiGetRequestMatcherDescriptorsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Descriptors
func (a *AuthenticationChallengePoliciesApiService) GetRequestMatcherDescriptorsExecute(r ApiGetRequestMatcherDescriptorsRequest) (*Descriptors, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Descriptors
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.GetRequestMatcherDescriptors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/requestMatchers/descriptors"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAuthenticationChallengePolicyRequest struct {
	ctx                           context.Context
	ApiService                    *AuthenticationChallengePoliciesApiService
	id                            string
	authenticationChallengePolicy *AuthenticationChallengePolicy
}

// Authentication Challenge Policy to update
func (r ApiUpdateAuthenticationChallengePolicyRequest) AuthenticationChallengePolicy(authenticationChallengePolicy AuthenticationChallengePolicy) ApiUpdateAuthenticationChallengePolicyRequest {
	r.authenticationChallengePolicy = &authenticationChallengePolicy
	return r
}

func (r ApiUpdateAuthenticationChallengePolicyRequest) Execute() (*AuthenticationChallengePolicy, *http.Response, error) {
	return r.ApiService.UpdateAuthenticationChallengePolicyExecute(r)
}

/*
UpdateAuthenticationChallengePolicy Method for UpdateAuthenticationChallengePolicy

Update an Authentication Challenge Policy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param id ID of the Authentication Challenge Policy to update
	@return ApiUpdateAuthenticationChallengePolicyRequest
*/
func (a *AuthenticationChallengePoliciesApiService) UpdateAuthenticationChallengePolicy(ctx context.Context, id string) ApiUpdateAuthenticationChallengePolicyRequest {
	return ApiUpdateAuthenticationChallengePolicyRequest{
		ApiService: a,
		ctx:        ctx,
		id:         id,
	}
}

// Execute executes the request
//
//	@return AuthenticationChallengePolicy
func (a *AuthenticationChallengePoliciesApiService) UpdateAuthenticationChallengePolicyExecute(r ApiUpdateAuthenticationChallengePolicyRequest) (*AuthenticationChallengePolicy, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AuthenticationChallengePolicy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AuthenticationChallengePoliciesApiService.UpdateAuthenticationChallengePolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/authenticationChallengePolicies/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authenticationChallengePolicy == nil {
		return localVarReturnValue, nil, reportError("authenticationChallengePolicy is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authenticationChallengePolicy
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
