/*
Administrative API Documentation

The PingAccess Administrative API is a REST-based interface that provides a programmatic way to make configuration changes to PingAccess as an alternative to using the administrative console.<br/><br/>Expand the resources below to display implementation details on that resource such as the available endpoints, the parameter and response models for the operation, and the model structure of the resources themselves. Each resource operation comes with the ability to interact with the API.

API version: 7.3.0.2-SNAPSHOT
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package configurationapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// AcmeApiService AcmeApi service
type AcmeApiService service

type ApiAddAcmeAccountRequest struct {
	ctx          context.Context
	ApiService   *AcmeApiService
	acmeServerId string
	acmeAccount  *AcmeAccount
}

// ACME Account to add
func (r ApiAddAcmeAccountRequest) AcmeAccount(acmeAccount AcmeAccount) ApiAddAcmeAccountRequest {
	r.acmeAccount = &acmeAccount
	return r
}

func (r ApiAddAcmeAccountRequest) Execute() (*AcmeAccount, *http.Response, error) {
	return r.ApiService.AddAcmeAccountExecute(r)
}

/*
AddAcmeAccount Method for AddAcmeAccount

Add an ACME Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ACME Server to add account to
	@return ApiAddAcmeAccountRequest
*/
func (a *AcmeApiService) AddAcmeAccount(ctx context.Context, acmeServerId string) ApiAddAcmeAccountRequest {
	return ApiAddAcmeAccountRequest{
		ApiService:   a,
		ctx:          ctx,
		acmeServerId: acmeServerId,
	}
}

// Execute executes the request
//
//	@return AcmeAccount
func (a *AcmeApiService) AddAcmeAccountExecute(r ApiAddAcmeAccountRequest) (*AcmeAccount, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.AddAcmeAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acmeAccount
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddAcmeCertificateRequestRequest struct {
	ctx                    context.Context
	ApiService             *AcmeApiService
	acmeServerId           string
	acmeAccountId          string
	acmeCertificateRequest *AcmeCertificateRequest
}

// ACME Certificate Request data
func (r ApiAddAcmeCertificateRequestRequest) AcmeCertificateRequest(acmeCertificateRequest AcmeCertificateRequest) ApiAddAcmeCertificateRequestRequest {
	r.acmeCertificateRequest = &acmeCertificateRequest
	return r
}

func (r ApiAddAcmeCertificateRequestRequest) Execute() (*AcmeCertificateRequest, *http.Response, error) {
	return r.ApiService.AddAcmeCertificateRequestExecute(r)
}

/*
AddAcmeCertificateRequest Method for AddAcmeCertificateRequest

Initiate the ACME protocol

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ACME Server that the account belongs to
	@param acmeAccountId ACME Account to add certificate to
	@return ApiAddAcmeCertificateRequestRequest
*/
func (a *AcmeApiService) AddAcmeCertificateRequest(ctx context.Context, acmeServerId string, acmeAccountId string) ApiAddAcmeCertificateRequestRequest {
	return ApiAddAcmeCertificateRequestRequest{
		ApiService:    a,
		ctx:           ctx,
		acmeServerId:  acmeServerId,
		acmeAccountId: acmeAccountId,
	}
}

// Execute executes the request
//
//	@return AcmeCertificateRequest
func (a *AcmeApiService) AddAcmeCertificateRequestExecute(r ApiAddAcmeCertificateRequestRequest) (*AcmeCertificateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeCertificateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.AddAcmeCertificateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}/certificateRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acmeCertificateRequest == nil {
		return localVarReturnValue, nil, reportError("acmeCertificateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acmeCertificateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddAcmeServerRequest struct {
	ctx        context.Context
	ApiService *AcmeApiService
	acmeServer *AcmeServer
}

// ACME Server to add
func (r ApiAddAcmeServerRequest) AcmeServer(acmeServer AcmeServer) ApiAddAcmeServerRequest {
	r.acmeServer = &acmeServer
	return r
}

func (r ApiAddAcmeServerRequest) Execute() (*AcmeServer, *http.Response, error) {
	return r.ApiService.AddAcmeServerExecute(r)
}

/*
AddAcmeServer Method for AddAcmeServer

Add an ACME Server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddAcmeServerRequest
*/
func (a *AcmeApiService) AddAcmeServer(ctx context.Context) ApiAddAcmeServerRequest {
	return ApiAddAcmeServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AcmeServer
func (a *AcmeApiService) AddAcmeServerExecute(r ApiAddAcmeServerRequest) (*AcmeServer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeServer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.AddAcmeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acmeServer == nil {
		return localVarReturnValue, nil, reportError("acmeServer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acmeServer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAcmeAccountRequest struct {
	ctx           context.Context
	ApiService    *AcmeApiService
	acmeServerId  string
	acmeAccountId string
}

func (r ApiDeleteAcmeAccountRequest) Execute() (*AcmeAccount, *http.Response, error) {
	return r.ApiService.DeleteAcmeAccountExecute(r)
}

/*
DeleteAcmeAccount Method for DeleteAcmeAccount

Delete an ACME Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server that holds account
	@param acmeAccountId ID of ACME Account to delete
	@return ApiDeleteAcmeAccountRequest
*/
func (a *AcmeApiService) DeleteAcmeAccount(ctx context.Context, acmeServerId string, acmeAccountId string) ApiDeleteAcmeAccountRequest {
	return ApiDeleteAcmeAccountRequest{
		ApiService:    a,
		ctx:           ctx,
		acmeServerId:  acmeServerId,
		acmeAccountId: acmeAccountId,
	}
}

// Execute executes the request
//
//	@return AcmeAccount
func (a *AcmeApiService) DeleteAcmeAccountExecute(r ApiDeleteAcmeAccountRequest) (*AcmeAccount, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.DeleteAcmeAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAcmeCertificateRequestRequest struct {
	ctx                      context.Context
	ApiService               *AcmeApiService
	acmeServerId             string
	acmeAccountId            string
	acmeCertificateRequestId string
}

func (r ApiDeleteAcmeCertificateRequestRequest) Execute() (*AcmeCertificateRequest, *http.Response, error) {
	return r.ApiService.DeleteAcmeCertificateRequestExecute(r)
}

/*
DeleteAcmeCertificateRequest Method for DeleteAcmeCertificateRequest

Delete an ACME Certificate Request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server that holds account
	@param acmeAccountId ID of an ACME Account
	@param acmeCertificateRequestId ID of ACME Certificate Request to delete
	@return ApiDeleteAcmeCertificateRequestRequest
*/
func (a *AcmeApiService) DeleteAcmeCertificateRequest(ctx context.Context, acmeServerId string, acmeAccountId string, acmeCertificateRequestId string) ApiDeleteAcmeCertificateRequestRequest {
	return ApiDeleteAcmeCertificateRequestRequest{
		ApiService:               a,
		ctx:                      ctx,
		acmeServerId:             acmeServerId,
		acmeAccountId:            acmeAccountId,
		acmeCertificateRequestId: acmeCertificateRequestId,
	}
}

// Execute executes the request
//
//	@return AcmeCertificateRequest
func (a *AcmeApiService) DeleteAcmeCertificateRequestExecute(r ApiDeleteAcmeCertificateRequestRequest) (*AcmeCertificateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeCertificateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.DeleteAcmeCertificateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}/certificateRequests/{acmeCertificateRequestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeCertificateRequestId"+"}", url.PathEscape(parameterValueToString(r.acmeCertificateRequestId, "acmeCertificateRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAcmeServerRequest struct {
	ctx          context.Context
	ApiService   *AcmeApiService
	acmeServerId string
}

func (r ApiDeleteAcmeServerRequest) Execute() (*AcmeServer, *http.Response, error) {
	return r.ApiService.DeleteAcmeServerExecute(r)
}

/*
DeleteAcmeServer Method for DeleteAcmeServer

Delete an ACME Server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server to delete
	@return ApiDeleteAcmeServerRequest
*/
func (a *AcmeApiService) DeleteAcmeServer(ctx context.Context, acmeServerId string) ApiDeleteAcmeServerRequest {
	return ApiDeleteAcmeServerRequest{
		ApiService:   a,
		ctx:          ctx,
		acmeServerId: acmeServerId,
	}
}

// Execute executes the request
//
//	@return AcmeServer
func (a *AcmeApiService) DeleteAcmeServerExecute(r ApiDeleteAcmeServerRequest) (*AcmeServer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeServer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.DeleteAcmeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeAccountRequest struct {
	ctx           context.Context
	ApiService    *AcmeApiService
	acmeServerId  string
	acmeAccountId string
}

func (r ApiGetAcmeAccountRequest) Execute() (*AcmeAccount, *http.Response, error) {
	return r.ApiService.GetAcmeAccountExecute(r)
}

/*
GetAcmeAccount Method for GetAcmeAccount

Get an ACME Account

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server that holds account
	@param acmeAccountId ID of ACME Account to get
	@return ApiGetAcmeAccountRequest
*/
func (a *AcmeApiService) GetAcmeAccount(ctx context.Context, acmeServerId string, acmeAccountId string) ApiGetAcmeAccountRequest {
	return ApiGetAcmeAccountRequest{
		ApiService:    a,
		ctx:           ctx,
		acmeServerId:  acmeServerId,
		acmeAccountId: acmeAccountId,
	}
}

// Execute executes the request
//
//	@return AcmeAccount
func (a *AcmeApiService) GetAcmeAccountExecute(r ApiGetAcmeAccountRequest) (*AcmeAccount, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeAccountsRequest struct {
	ctx           context.Context
	ApiService    *AcmeApiService
	acmeServerId  string
	page          *int64
	numberPerPage *int64
	sortKey       *string
	order         *string
}

// Page number to retrieve
func (r ApiGetAcmeAccountsRequest) Page(page int64) ApiGetAcmeAccountsRequest {
	r.page = &page
	return r
}

// Number of ACME Accounts per page
func (r ApiGetAcmeAccountsRequest) NumberPerPage(numberPerPage int64) ApiGetAcmeAccountsRequest {
	r.numberPerPage = &numberPerPage
	return r
}

// A comma separated list of ACME Account attributes (keys) to be used to sort the results
func (r ApiGetAcmeAccountsRequest) SortKey(sortKey string) ApiGetAcmeAccountsRequest {
	r.sortKey = &sortKey
	return r
}

// Order of the sorted results (ASC for ascending, DESC for descending)
func (r ApiGetAcmeAccountsRequest) Order(order string) ApiGetAcmeAccountsRequest {
	r.order = &order
	return r
}

func (r ApiGetAcmeAccountsRequest) Execute() (*AcmeAccount, *http.Response, error) {
	return r.ApiService.GetAcmeAccountsExecute(r)
}

/*
GetAcmeAccounts Method for GetAcmeAccounts

Get all ACME Accounts

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server that holds accounts
	@return ApiGetAcmeAccountsRequest
*/
func (a *AcmeApiService) GetAcmeAccounts(ctx context.Context, acmeServerId string) ApiGetAcmeAccountsRequest {
	return ApiGetAcmeAccountsRequest{
		ApiService:   a,
		ctx:          ctx,
		acmeServerId: acmeServerId,
	}
}

// Execute executes the request
//
//	@return AcmeAccount
func (a *AcmeApiService) GetAcmeAccountsExecute(r ApiGetAcmeAccountsRequest) (*AcmeAccount, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeAccount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeAccounts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.numberPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberPerPage", r.numberPerPage, "")
	}
	if r.sortKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortKey", r.sortKey, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeCertificateRequestRequest struct {
	ctx                      context.Context
	ApiService               *AcmeApiService
	acmeServerId             string
	acmeAccountId            string
	acmeCertificateRequestId string
}

func (r ApiGetAcmeCertificateRequestRequest) Execute() (*AcmeCertificateRequest, *http.Response, error) {
	return r.ApiService.GetAcmeCertificateRequestExecute(r)
}

/*
GetAcmeCertificateRequest Method for GetAcmeCertificateRequest

Get an ACME Certificate Request

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server that holds account
	@param acmeAccountId ID of the ACME Account
	@param acmeCertificateRequestId ID of ACME Certificate Request to get
	@return ApiGetAcmeCertificateRequestRequest
*/
func (a *AcmeApiService) GetAcmeCertificateRequest(ctx context.Context, acmeServerId string, acmeAccountId string, acmeCertificateRequestId string) ApiGetAcmeCertificateRequestRequest {
	return ApiGetAcmeCertificateRequestRequest{
		ApiService:               a,
		ctx:                      ctx,
		acmeServerId:             acmeServerId,
		acmeAccountId:            acmeAccountId,
		acmeCertificateRequestId: acmeCertificateRequestId,
	}
}

// Execute executes the request
//
//	@return AcmeCertificateRequest
func (a *AcmeApiService) GetAcmeCertificateRequestExecute(r ApiGetAcmeCertificateRequestRequest) (*AcmeCertificateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeCertificateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeCertificateRequest")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}/certificateRequests/{acmeCertificateRequestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeCertificateRequestId"+"}", url.PathEscape(parameterValueToString(r.acmeCertificateRequestId, "acmeCertificateRequestId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeCertificateRequestsRequest struct {
	ctx           context.Context
	ApiService    *AcmeApiService
	acmeServerId  string
	acmeAccountId string
	keyPairId     *string
	page          *int64
	numberPerPage *int64
	sortKey       *string
	order         *string
}

// ID of the Key Pair
func (r ApiGetAcmeCertificateRequestsRequest) KeyPairId(keyPairId string) ApiGetAcmeCertificateRequestsRequest {
	r.keyPairId = &keyPairId
	return r
}

// Page number to retrieve
func (r ApiGetAcmeCertificateRequestsRequest) Page(page int64) ApiGetAcmeCertificateRequestsRequest {
	r.page = &page
	return r
}

// Number of ACME Certificate Requests per page
func (r ApiGetAcmeCertificateRequestsRequest) NumberPerPage(numberPerPage int64) ApiGetAcmeCertificateRequestsRequest {
	r.numberPerPage = &numberPerPage
	return r
}

// A comma separated list of ACME Certificate Request attributes (keys) to be used to sort the results
func (r ApiGetAcmeCertificateRequestsRequest) SortKey(sortKey string) ApiGetAcmeCertificateRequestsRequest {
	r.sortKey = &sortKey
	return r
}

// Order of the sorted results (ASC for ascending, DESC for descending)
func (r ApiGetAcmeCertificateRequestsRequest) Order(order string) ApiGetAcmeCertificateRequestsRequest {
	r.order = &order
	return r
}

func (r ApiGetAcmeCertificateRequestsRequest) Execute() (*AcmeCertificateRequest, *http.Response, error) {
	return r.ApiService.GetAcmeCertificateRequestsExecute(r)
}

/*
GetAcmeCertificateRequests Method for GetAcmeCertificateRequests

Get all ACME Certificate Requests

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of the ACME Server
	@param acmeAccountId ID of the ACME Account
	@return ApiGetAcmeCertificateRequestsRequest
*/
func (a *AcmeApiService) GetAcmeCertificateRequests(ctx context.Context, acmeServerId string, acmeAccountId string) ApiGetAcmeCertificateRequestsRequest {
	return ApiGetAcmeCertificateRequestsRequest{
		ApiService:    a,
		ctx:           ctx,
		acmeServerId:  acmeServerId,
		acmeAccountId: acmeAccountId,
	}
}

// Execute executes the request
//
//	@return AcmeCertificateRequest
func (a *AcmeApiService) GetAcmeCertificateRequestsExecute(r ApiGetAcmeCertificateRequestsRequest) (*AcmeCertificateRequest, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeCertificateRequest
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeCertificateRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}/accounts/{acmeAccountId}/certificateRequests"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"acmeAccountId"+"}", url.PathEscape(parameterValueToString(r.acmeAccountId, "acmeAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.keyPairId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "keyPairId", r.keyPairId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.numberPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberPerPage", r.numberPerPage, "")
	}
	if r.sortKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortKey", r.sortKey, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeServerRequest struct {
	ctx          context.Context
	ApiService   *AcmeApiService
	acmeServerId string
}

func (r ApiGetAcmeServerRequest) Execute() (*AcmeServer, *http.Response, error) {
	return r.ApiService.GetAcmeServerExecute(r)
}

/*
GetAcmeServer Method for GetAcmeServer

Get an ACME Server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param acmeServerId ID of ACME Server to get
	@return ApiGetAcmeServerRequest
*/
func (a *AcmeApiService) GetAcmeServer(ctx context.Context, acmeServerId string) ApiGetAcmeServerRequest {
	return ApiGetAcmeServerRequest{
		ApiService:   a,
		ctx:          ctx,
		acmeServerId: acmeServerId,
	}
}

// Execute executes the request
//
//	@return AcmeServer
func (a *AcmeApiService) GetAcmeServerExecute(r ApiGetAcmeServerRequest) (*AcmeServer, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeServer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/{acmeServerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"acmeServerId"+"}", url.PathEscape(parameterValueToString(r.acmeServerId, "acmeServerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAcmeServersRequest struct {
	ctx           context.Context
	ApiService    *AcmeApiService
	page          *int64
	numberPerPage *int64
	filter        *string
	name          *string
	sortKey       *string
	order         *string
}

// Page number to retrieve
func (r ApiGetAcmeServersRequest) Page(page int64) ApiGetAcmeServersRequest {
	r.page = &page
	return r
}

// Number of ACME Servers per page
func (r ApiGetAcmeServersRequest) NumberPerPage(numberPerPage int64) ApiGetAcmeServersRequest {
	r.numberPerPage = &numberPerPage
	return r
}

// Search for ACME Server with name matching filter text
func (r ApiGetAcmeServersRequest) Filter(filter string) ApiGetAcmeServersRequest {
	r.filter = &filter
	return r
}

// Get a specific ACME Server by name (case-sensitive)
func (r ApiGetAcmeServersRequest) Name(name string) ApiGetAcmeServersRequest {
	r.name = &name
	return r
}

// A comma separated list of ACME Server attributes (keys) to be used to sort the results
func (r ApiGetAcmeServersRequest) SortKey(sortKey string) ApiGetAcmeServersRequest {
	r.sortKey = &sortKey
	return r
}

// Order of the sorted results (ASC for ascending, DESC for descending)
func (r ApiGetAcmeServersRequest) Order(order string) ApiGetAcmeServersRequest {
	r.order = &order
	return r
}

func (r ApiGetAcmeServersRequest) Execute() (*AcmeServers, *http.Response, error) {
	return r.ApiService.GetAcmeServersExecute(r)
}

/*
GetAcmeServers Method for GetAcmeServers

Get all ACME Servers

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAcmeServersRequest
*/
func (a *AcmeApiService) GetAcmeServers(ctx context.Context) ApiGetAcmeServersRequest {
	return ApiGetAcmeServersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AcmeServers
func (a *AcmeApiService) GetAcmeServersExecute(r ApiGetAcmeServersRequest) (*AcmeServers, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AcmeServers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetAcmeServers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.numberPerPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberPerPage", r.numberPerPage, "")
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.sortKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortKey", r.sortKey, "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultAcmeServerRequest struct {
	ctx        context.Context
	ApiService *AcmeApiService
}

func (r ApiGetDefaultAcmeServerRequest) Execute() (*Link, *http.Response, error) {
	return r.ApiService.GetDefaultAcmeServerExecute(r)
}

/*
GetDefaultAcmeServer Method for GetDefaultAcmeServer

Get the default ACME Server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDefaultAcmeServerRequest
*/
func (a *AcmeApiService) GetDefaultAcmeServer(ctx context.Context) ApiGetDefaultAcmeServerRequest {
	return ApiGetDefaultAcmeServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Link
func (a *AcmeApiService) GetDefaultAcmeServerExecute(r ApiGetDefaultAcmeServerRequest) (*Link, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Link
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.GetDefaultAcmeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDefaultAcmeServerRequest struct {
	ctx        context.Context
	ApiService *AcmeApiService
	acmeServer *Link
}

// ACME Server to update
func (r ApiUpdateDefaultAcmeServerRequest) AcmeServer(acmeServer Link) ApiUpdateDefaultAcmeServerRequest {
	r.acmeServer = &acmeServer
	return r
}

func (r ApiUpdateDefaultAcmeServerRequest) Execute() (*Link, *http.Response, error) {
	return r.ApiService.UpdateDefaultAcmeServerExecute(r)
}

/*
UpdateDefaultAcmeServer Method for UpdateDefaultAcmeServer

Update the default ACME Server

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUpdateDefaultAcmeServerRequest
*/
func (a *AcmeApiService) UpdateDefaultAcmeServer(ctx context.Context) ApiUpdateDefaultAcmeServerRequest {
	return ApiUpdateDefaultAcmeServerRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return Link
func (a *AcmeApiService) UpdateDefaultAcmeServerExecute(r ApiUpdateDefaultAcmeServerRequest) (*Link, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Link
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AcmeApiService.UpdateDefaultAcmeServer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/acme/servers/default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acmeServer == nil {
		return localVarReturnValue, nil, reportError("acmeServer is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.acmeServer
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ApiError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
